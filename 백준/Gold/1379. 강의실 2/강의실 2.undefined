use std::{
    collections::BinaryHeap,
    fmt::Write,
    io::{read_to_string, stdin},
};

fn main() {
    let stdin = read_to_string(stdin()).unwrap();
    let mut token = stdin.split_whitespace();
    let mut next = || token.next().unwrap();

    let n = next().parse::<usize>().unwrap();
    let mut nums = (0..n)
        .map(|_| {
            (
                next().parse::<usize>().unwrap(),
                next().parse::<i64>().unwrap(),
                next().parse::<i64>().unwrap(),
            )
        })
        .collect::<Vec<_>>();
    print!("{}", solve(n, &mut nums));
}

fn solve(n: usize, nums: &mut Vec<(usize, i64, i64)>) -> String {
    let mut res = String::with_capacity(n);
    let mut hq = BinaryHeap::new();
    nums.sort_unstable_by_key(|x| (x.1, x.2));

    let mut room = vec![0; n];
    let mut k = 1;

    for (idx, st, ed) in nums {
        if hq.is_empty() {
            room[*idx - 1] = k;
            hq.push((-*ed, st, idx, k));
            k += 1;
            continue;
        }
        if let Some((pre_ed, _, _, _)) = hq.peek()
            && -*pre_ed <= *st
        {
            let (_, _, _, pre_k) = hq.pop().unwrap();
            room[*idx - 1] = pre_k;
            hq.push((-*ed, st, idx, pre_k));
        } else {
            room[*idx - 1] = k;
            hq.push((-*ed, st, idx, k));
            k += 1;
        }
    }

    write!(res, "{} ", hq.len()).unwrap();
    for i in 0..n {
        write!(res, "{} ", room[i]).unwrap();
    }

    res
}