use std::collections::VecDeque;
use std::io::{read_to_string, stdin};

const INF: u32 = 1_000_000_000;

fn main() {
    let stdin = read_to_string(stdin()).unwrap();
    let mut token = stdin.split_whitespace();
    let mut next = || token.next().unwrap();

    let n: usize = next().parse().unwrap();
    let board: Vec<Vec<usize>> = (0..n)
        .map(|_| (0..n).map(|_| next().parse::<usize>().unwrap()).collect())
        .collect();

    let mut idx = vec![(0, 0); n * n + 2];

    for i in 0..n {
        for j in 0..n {
            idx[board[i][j]] = (i, j);
        }
    }

    // dummy
    idx[n * n + 1] = (0, 0);

    let nn = n as i32;
    let mut visited = vec![vec![vec![vec![INF; n * n + 1]; 3]; n]; n];
    let (st_y, st_x) = idx[1];

    // knight
    visited[st_y][st_x][0][1] = 0;
    // rook
    visited[st_y][st_x][1][1] = 0;
    // bishop
    visited[st_y][st_x][2][1] = 0;

    let mut queue = VecDeque::new();
    queue.push_back((1, 0, st_y as i32, st_x as i32));
    queue.push_back((1, 1, st_y as i32, st_x as i32));
    queue.push_back((1, 2, st_y as i32, st_x as i32));

    while let Some((i, p, y, x)) = queue.pop_front() {
        let yy = y as usize;
        let xx = x as usize;

        let (nxt_y, nxt_x) = idx[i + 1];

        let cost = if p == 0 { 1 } else { 2 };
        for (dy, dx) in vec![
            (2, 1),
            (1, 2),
            (2, -1),
            (1, -2),
            (-2, 1),
            (-1, 2),
            (-2, -1),
            (-1, -2),
        ] {
            let ny = dy + y;
            let nx = dx + x;
            if ny < 0 || nx < 0 || ny >= nn || nx >= nn {
                continue;
            }
            let ny = ny as usize;
            let nx = nx as usize;

            // lst is knignt

            if visited[yy][xx][p][i] + cost < visited[ny][nx][0][i] {
                visited[ny][nx][0][i] = visited[yy][xx][p][i] + cost;
                queue.push_back((i, 0, ny as i32, nx as i32));
            }
            if i + 1 <= n * n
                && ny == nxt_y
                && nx == nxt_x
                && visited[yy][xx][p][i] + cost < visited[ny][nx][0][i + 1]
            {
                visited[ny][nx][0][i + 1] = visited[yy][xx][p][i] + cost;
                queue.push_back((i + 1, 0, ny as i32, nx as i32));
            }
        }

        let cost = if p == 1 { 1 } else { 2 };
        for (dy, dx) in vec![(0, 1), (0, -1), (1, 0), (-1, 0)] {
            for nxt in 1..=nn {
                let ny = dy * nxt + y;
                let nx = dx * nxt + x;
                if ny < 0 || nx < 0 || ny >= nn || nx >= nn {
                    continue;
                }
                let ny = ny as usize;
                let nx = nx as usize;

                // lst is rook
                if visited[yy][xx][p][i] + cost < visited[ny][nx][1][i] {
                    visited[ny][nx][1][i] = visited[yy][xx][p][i] + cost;
                    queue.push_back((i, 1, ny as i32, nx as i32));
                }
                if i + 1 <= n * n
                    && ny == nxt_y
                    && nx == nxt_x
                    && visited[yy][xx][p][i] + cost < visited[ny][nx][1][i + 1]
                {
                    visited[ny][nx][1][i + 1] = visited[yy][xx][p][i] + cost;
                    queue.push_back((i + 1, 1, ny as i32, nx as i32));
                }
            }
        }

        let cost = if p == 2 { 1 } else { 2 };
        for (dy, dx) in vec![(1, 1), (1, -1), (-1, 1), (-1, -1)] {
            for nxt in 1..=nn {
                let ny = dy * nxt + y;
                let nx = dx * nxt + x;
                if ny < 0 || nx < 0 || ny >= nn || nx >= nn {
                    continue;
                }
                let ny = ny as usize;
                let nx = nx as usize;

                // lst is bishop
                if visited[yy][xx][p][i] + cost < visited[ny][nx][2][i] {
                    visited[ny][nx][2][i] = visited[yy][xx][p][i] + cost;
                    queue.push_back((i, 2, ny as i32, nx as i32));
                }
                if i + 1 <= n * n
                    && ny == nxt_y
                    && nx == nxt_x
                    && visited[yy][xx][p][i] + cost < visited[ny][nx][2][i + 1]
                {
                    visited[ny][nx][2][i + 1] = visited[yy][xx][p][i] + cost;
                    queue.push_back((i + 1, 2, ny as i32, nx as i32));
                }
            }
        }
    }

    let (lst_y, lst_x) = idx[n * n];
    let mut res = INF;

    for i in 0..3 {
        res = res.min(visited[lst_y][lst_x][i][n * n]);
    }
    print!("{res}");
}
